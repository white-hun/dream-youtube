{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\White\\\\Desktop\\\\dream-youtube\\\\dream-youtube\\\\src\\\\pages\\\\Videos.jsx\",\n  _s = $RefreshSig$();\nimport React from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams } from \"react-router-dom\";\nimport VideoCard from \"../components/VideoCard\";\n\n// import FakeYoutube from \"../api/fakeYououtube\";\nimport Youtube from \"../api/youtube\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function Videos() {\n  _s();\n  const {\n    keyword\n  } = useParams();\n  const {\n    isLoading,\n    error,\n    data: videos\n  } = useQuery([\"videos\", keyword], () => {\n    // const youtube = new FakeYoutube();\n    const youtube = new Youtube();\n    return youtube.search(keyword);\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      children: [\"Videos \", keyword ? `🔍${keyword}` : `🔥`]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 22,\n      columnNumber: 7\n    }, this), isLoading && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Loading...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 21\n    }, this), error && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: error.message\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 17\n    }, this), videos && /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: videos.map(video => /*#__PURE__*/_jsxDEV(VideoCard, {\n        video: video\n      }, video.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 13\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true);\n}\n\n// fetch의 문제점\n// fetch는 데이터를 받아왔다고 판단할 때 then으로 보내게 되는데\n// 백엔드에서 status 코드를 보낼 때도 데이터를 받아오는 것이기 때문에\n// 정상코드인 200을 받든, 404 notfound, 400 params error받든 데이터로 판단해서 error라도\n// then으로 보내게된다\n// 그럼 then안에서 throw를 사용해서 status 코드가 200대가 아니면 수동적으로 error를 처리해야한다\n// 이것을 해결하기 위해 axios를 사용한다\n\n// 200대는 axios로 200대가 아니거나 400대는 catch로 들어간다\n// 네트워크 통신 에러 뿐만 아니라 백엔드에서 데이터를 제대로 처리하지 못한경우도 catch로 들어온다\n// 새로운 데이터를 사용하는 경우 post함수 사용\n\n// useQuery는 비동기 상태관리를 해주는 라이브러리일 뿐 비동기 행동이 무엇인지는 결정되어 있지 않다\n// FE에서 비동기라고 하면 네트워크 통신을 말할수도 있지만\n// 네트워크 통신 뿐만아니라 특정한 비동기적인 행동을 하는 경우에도 useQuery를 사용할 수 있다\n// useQuery자체로는 어떻게 네트워크 통신을 해야하는지 네트워크 통신에 관련된 문제는 해결해주지 않는다\n\n// 문제점\n// 1. 실제 API를 사용해서 YouTube API와 잘되는지 만든 APP이 잘 동작하는지 확인이 필요한데 Mock data와 실제 API를 스위칭 하는 방법이 필요하다\n// 2. 컴포넌트 내에 네트워크 통신 내부 구현 사항이 너무 많이 노출되어 있다\n// 또 다른 부분에서 특정 동작(ex.검색기능)에 관해서 사용해야한다면 동일한 코드를 다시 구현해야하는데 재사용성, 유지보수가 떨어진다. useQuery의 callback함수에 내용이 다 포함 되어 있기 때문에 가독성도 떨어진다\n// 그래서 대부분 api를 따로 뺴서 관리하는데 --> /api/youtube.js\n// 그 후 useQuery 두 번째 인자 callback함수에 작성한 api를 사용한다\n// 컴포넌트에서는 어떤 네트워크 통신도 신경쓰지 않는다\n\n// youtube.js라는 동일한 함수(동인한 api)들이 있는 두가지 구현 사항을 만든다\n//  search라는 api가 있으면\n// 하나는 Fake(json에서 읽어오는 데이터)\n// 다른 하나는 Implementation(실제 api의 데이터)\n//---------------------------------------------------------------------------------------------\n\n// import React from \"react\";\n// import { useQuery } from \"@tanstack/react-query\";\n// import { useParams } from \"react-router-dom\";\n// import VideoCard from \"../components/VideoCard\";\n\n// export default function Videos() {\n//   const { keyword } = useParams();\n//   // 1.인자 key 안에 키워드 별로 캐시가 되도록 한다\n//   //2.인자 어떻게 네트워크 통신을 할 건지\n//   const {\n//     isLoading,\n//     error,\n//     data: videos,\n//   } = useQuery([\"videos\", keyword], async () => {\n//     return fetch(`/videos/${keyword ? keyword : \"popular\"}.json`)\n//       .then((res) => res.json())\n//       .then((data) => data.items);\n//   });\n//   return (\n//     <>\n//       <div>Videos {keyword ? `🔍${keyword}` : `🔥`}</div>\n//       {isLoading && <p>Loading...</p>}\n//       {error && <p>{error.message}</p>}\n//       {videos && (\n//         <ul>\n//           {videos.map((video) => (\n//             <VideoCard key={video.id} video={video} />\n//           ))}\n//         </ul>\n//       )}\n//     </>\n//   );\n// }\n_s(Videos, \"uTyZWwjvnb1o/wiIDBdSUWVjHAQ=\", false, function () {\n  return [useParams, useQuery];\n});\n_c = Videos;\nvar _c;\n$RefreshReg$(_c, \"Videos\");","map":{"version":3,"names":["React","useQuery","useParams","VideoCard","Youtube","jsxDEV","_jsxDEV","Fragment","_Fragment","Videos","_s","keyword","isLoading","error","data","videos","youtube","search","children","fileName","_jsxFileName","lineNumber","columnNumber","message","map","video","id","_c","$RefreshReg$"],"sources":["C:/Users/White/Desktop/dream-youtube/dream-youtube/src/pages/Videos.jsx"],"sourcesContent":["import React from \"react\";\r\nimport { useQuery } from \"@tanstack/react-query\";\r\nimport { useParams } from \"react-router-dom\";\r\nimport VideoCard from \"../components/VideoCard\";\r\n\r\n// import FakeYoutube from \"../api/fakeYououtube\";\r\nimport Youtube from \"../api/youtube\";\r\n\r\nexport default function Videos() {\r\n  const { keyword } = useParams();\r\n  const {\r\n    isLoading,\r\n    error,\r\n    data: videos,\r\n  } = useQuery([\"videos\", keyword], () => {\r\n    // const youtube = new FakeYoutube();\r\n    const youtube = new Youtube();\r\n    return youtube.search(keyword);\r\n  });\r\n  return (\r\n    <>\r\n      <div>Videos {keyword ? `🔍${keyword}` : `🔥`}</div>\r\n      {isLoading && <p>Loading...</p>}\r\n      {error && <p>{error.message}</p>}\r\n      {videos && (\r\n        <ul>\r\n          {videos.map((video) => (\r\n            <VideoCard key={video.id} video={video} />\r\n          ))}\r\n        </ul>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\n// fetch의 문제점\r\n// fetch는 데이터를 받아왔다고 판단할 때 then으로 보내게 되는데\r\n// 백엔드에서 status 코드를 보낼 때도 데이터를 받아오는 것이기 때문에\r\n// 정상코드인 200을 받든, 404 notfound, 400 params error받든 데이터로 판단해서 error라도\r\n// then으로 보내게된다\r\n// 그럼 then안에서 throw를 사용해서 status 코드가 200대가 아니면 수동적으로 error를 처리해야한다\r\n// 이것을 해결하기 위해 axios를 사용한다\r\n\r\n// 200대는 axios로 200대가 아니거나 400대는 catch로 들어간다\r\n// 네트워크 통신 에러 뿐만 아니라 백엔드에서 데이터를 제대로 처리하지 못한경우도 catch로 들어온다\r\n// 새로운 데이터를 사용하는 경우 post함수 사용\r\n\r\n// useQuery는 비동기 상태관리를 해주는 라이브러리일 뿐 비동기 행동이 무엇인지는 결정되어 있지 않다\r\n// FE에서 비동기라고 하면 네트워크 통신을 말할수도 있지만\r\n// 네트워크 통신 뿐만아니라 특정한 비동기적인 행동을 하는 경우에도 useQuery를 사용할 수 있다\r\n// useQuery자체로는 어떻게 네트워크 통신을 해야하는지 네트워크 통신에 관련된 문제는 해결해주지 않는다\r\n\r\n// 문제점\r\n// 1. 실제 API를 사용해서 YouTube API와 잘되는지 만든 APP이 잘 동작하는지 확인이 필요한데 Mock data와 실제 API를 스위칭 하는 방법이 필요하다\r\n// 2. 컴포넌트 내에 네트워크 통신 내부 구현 사항이 너무 많이 노출되어 있다\r\n// 또 다른 부분에서 특정 동작(ex.검색기능)에 관해서 사용해야한다면 동일한 코드를 다시 구현해야하는데 재사용성, 유지보수가 떨어진다. useQuery의 callback함수에 내용이 다 포함 되어 있기 때문에 가독성도 떨어진다\r\n// 그래서 대부분 api를 따로 뺴서 관리하는데 --> /api/youtube.js\r\n// 그 후 useQuery 두 번째 인자 callback함수에 작성한 api를 사용한다\r\n// 컴포넌트에서는 어떤 네트워크 통신도 신경쓰지 않는다\r\n\r\n// youtube.js라는 동일한 함수(동인한 api)들이 있는 두가지 구현 사항을 만든다\r\n//  search라는 api가 있으면\r\n// 하나는 Fake(json에서 읽어오는 데이터)\r\n// 다른 하나는 Implementation(실제 api의 데이터)\r\n//---------------------------------------------------------------------------------------------\r\n\r\n// import React from \"react\";\r\n// import { useQuery } from \"@tanstack/react-query\";\r\n// import { useParams } from \"react-router-dom\";\r\n// import VideoCard from \"../components/VideoCard\";\r\n\r\n// export default function Videos() {\r\n//   const { keyword } = useParams();\r\n//   // 1.인자 key 안에 키워드 별로 캐시가 되도록 한다\r\n//   //2.인자 어떻게 네트워크 통신을 할 건지\r\n//   const {\r\n//     isLoading,\r\n//     error,\r\n//     data: videos,\r\n//   } = useQuery([\"videos\", keyword], async () => {\r\n//     return fetch(`/videos/${keyword ? keyword : \"popular\"}.json`)\r\n//       .then((res) => res.json())\r\n//       .then((data) => data.items);\r\n//   });\r\n//   return (\r\n//     <>\r\n//       <div>Videos {keyword ? `🔍${keyword}` : `🔥`}</div>\r\n//       {isLoading && <p>Loading...</p>}\r\n//       {error && <p>{error.message}</p>}\r\n//       {videos && (\r\n//         <ul>\r\n//           {videos.map((video) => (\r\n//             <VideoCard key={video.id} video={video} />\r\n//           ))}\r\n//         </ul>\r\n//       )}\r\n//     </>\r\n//   );\r\n// }\r\n"],"mappings":";;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,SAAS,QAAQ,kBAAkB;AAC5C,OAAOC,SAAS,MAAM,yBAAyB;;AAE/C;AACA,OAAOC,OAAO,MAAM,gBAAgB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAAA,SAAAC,QAAA,IAAAC,SAAA;AAErC,eAAe,SAASC,MAAMA,CAAA,EAAG;EAAAC,EAAA;EAC/B,MAAM;IAAEC;EAAQ,CAAC,GAAGT,SAAS,EAAE;EAC/B,MAAM;IACJU,SAAS;IACTC,KAAK;IACLC,IAAI,EAAEC;EACR,CAAC,GAAGd,QAAQ,CAAC,CAAC,QAAQ,EAAEU,OAAO,CAAC,EAAE,MAAM;IACtC;IACA,MAAMK,OAAO,GAAG,IAAIZ,OAAO,EAAE;IAC7B,OAAOY,OAAO,CAACC,MAAM,CAACN,OAAO,CAAC;EAChC,CAAC,CAAC;EACF,oBACEL,OAAA,CAAAE,SAAA;IAAAU,QAAA,gBACEZ,OAAA;MAAAY,QAAA,GAAK,SAAO,EAACP,OAAO,GAAI,KAAIA,OAAQ,EAAC,GAAI,IAAG;IAAA;MAAAQ,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAO,EAClDV,SAAS,iBAAIN,OAAA;MAAAY,QAAA,EAAG;IAAU;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAI,EAC9BT,KAAK,iBAAIP,OAAA;MAAAY,QAAA,EAAIL,KAAK,CAACU;IAAO;MAAAJ,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAK,EAC/BP,MAAM,iBACLT,OAAA;MAAAY,QAAA,EACGH,MAAM,CAACS,GAAG,CAAEC,KAAK,iBAChBnB,OAAA,CAACH,SAAS;QAAgBsB,KAAK,EAAEA;MAAM,GAAvBA,KAAK,CAACC,EAAE;QAAAP,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QACzB;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAEL;EAAA,gBACA;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAAZ,EAAA,CA1FwBD,MAAM;EAAA,QACRP,SAAS,EAKzBD,QAAQ;AAAA;AAAA0B,EAAA,GANUlB,MAAM;AAAA,IAAAkB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}